

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mysql_save_load &mdash; Bayesian Inference Framework 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Bayesian Inference Framework
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Python API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Bayesian-Markov-chain-Monte-Carlo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Bayesian Inference Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">mysql_save_load</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for mysql_save_load</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">imports</span> <span class="kn">import</span> <span class="o">*</span>


<div class="viewcode-block" id="save_object">
<a class="viewcode-back" href="../mysql_save_load.html#mysql_save_load.save_object">[docs]</a>
<span class="k">def</span> <span class="nf">save_object</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">database</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">5000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save numerical data to a MySQL database in batched chunks for efficient storage.</span>
<span class="sd">    </span>
<span class="sd">    This function stores numerical data (typically NumPy arrays or lists) into a MySQL</span>
<span class="sd">    database table with automatic chunking for memory efficiency and performance optimization.</span>
<span class="sd">    The function creates the table if it doesn&#39;t exist and automatically assigns sequential</span>
<span class="sd">    IDs to maintain data order and integrity.</span>
<span class="sd">    </span>
<span class="sd">    The chunking mechanism is particularly useful for large datasets that might exceed</span>
<span class="sd">    MySQL&#39;s maximum packet size or cause memory issues. Each chunk is inserted as a</span>
<span class="sd">    single transaction for better performance compared to individual row insertions.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        data (array-like): Numerical data to be saved. Can be a NumPy array, list,</span>
<span class="sd">                          or any iterable containing numerical values. Will be converted</span>
<span class="sd">                          to float type during insertion.</span>
<span class="sd">        host (str): MySQL server hostname or IP address (e.g., &#39;localhost&#39;, &#39;192.168.1.100&#39;).</span>
<span class="sd">        user (str): MySQL username with INSERT privileges on the specified database.</span>
<span class="sd">        password (str): Password for the MySQL user account.</span>
<span class="sd">        database (str): Name of the MySQL database where data will be stored.</span>
<span class="sd">                       Database must exist before calling this function.</span>
<span class="sd">        chunk_size (int, optional): Number of data points to insert per batch operation.</span>
<span class="sd">                                   Larger chunks improve performance but use more memory.</span>
<span class="sd">                                   Defaults to 5000. Adjust based on data size and memory constraints.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        mysql.connector.Error: If database connection fails, authentication is invalid,</span>
<span class="sd">                              or SQL execution encounters errors.</span>
<span class="sd">        ValueError: If data contains non-numerical values that cannot be converted to float.</span>
<span class="sd">        MemoryError: If chunk_size is too large for available memory.</span>
<span class="sd">    </span>
<span class="sd">    Database Schema:</span>
<span class="sd">        Creates table &#39;my_table&#39; with the following structure:</span>
<span class="sd">        - id (INT PRIMARY KEY): Sequential identifier starting from 1</span>
<span class="sd">        - value (FLOAT): The numerical data value</span>
<span class="sd">    </span>
<span class="sd">    Performance Considerations:</span>
<span class="sd">        - Uses batched INSERT statements to minimize database round trips</span>
<span class="sd">        - Automatically determines starting ID to append to existing data</span>
<span class="sd">        - Commits all changes in a single transaction for consistency</span>
<span class="sd">        - Chunk size can be tuned for optimal performance vs. memory trade-off</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Save a NumPy array</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.random(10000)</span>
<span class="sd">        &gt;&gt;&gt; save_object(data, &#39;localhost&#39;, &#39;myuser&#39;, &#39;mypass&#39;, &#39;mydb&#39;)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Save with custom chunk size for large datasets</span>
<span class="sd">        &gt;&gt;&gt; large_data = np.arange(1000000)</span>
<span class="sd">        &gt;&gt;&gt; save_object(large_data, &#39;localhost&#39;, &#39;myuser&#39;, &#39;mypass&#39;, &#39;mydb&#39;, chunk_size=10000)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Save a simple list</span>
<span class="sd">        &gt;&gt;&gt; measurements = [1.2, 3.4, 5.6, 7.8, 9.0]</span>
<span class="sd">        &gt;&gt;&gt; save_object(measurements, &#39;db.example.com&#39;, &#39;analyst&#39;, &#39;secure123&#39;, &#39;experiments&#39;)</span>
<span class="sd">    </span>
<span class="sd">    Security Notes:</span>
<span class="sd">        - Uses parameterized queries to prevent SQL injection</span>
<span class="sd">        - Credentials are passed directly; consider using environment variables</span>
<span class="sd">        - Ensure proper database user permissions (INSERT, SELECT on target table)</span>
<span class="sd">        - Connection uses default MySQL encryption settings</span>
<span class="sd">    </span>
<span class="sd">    Data Integrity:</span>
<span class="sd">        - Each save operation appends to existing data (preserves previous records)</span>
<span class="sd">        - Sequential IDs maintain insertion order for data retrieval</span>
<span class="sd">        - Single transaction ensures all-or-nothing behavior for each function call</span>
<span class="sd">        - Existing data is never modified, only new records are added</span>
<span class="sd">    </span>
<span class="sd">    Troubleshooting:</span>
<span class="sd">        - Verify database exists and user has appropriate permissions</span>
<span class="sd">        - Check network connectivity to MySQL server</span>
<span class="sd">        - Ensure chunk_size doesn&#39;t exceed MySQL&#39;s max_allowed_packet setting</span>
<span class="sd">        - Monitor memory usage for very large datasets</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Connect to the MySQL server</span>
    <span class="n">cnx</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connector</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="n">database</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">cnx</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="c1"># Create a table if it doesn&#39;t exist already</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE IF NOT EXISTS my_table (id INT PRIMARY KEY, value FLOAT)&quot;</span><span class="p">)</span>

    <span class="c1"># Retrieve the maximum ID from the table</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT MAX(id) FROM my_table&quot;</span><span class="p">)</span>
    <span class="n">max_id</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If there are no records in the table, set the maximum ID to 0</span>
    <span class="k">if</span> <span class="n">max_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Split the data into chunks</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)))</span>

    <span class="c1"># Iterate over each chunk and insert it into the table</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="c1"># Prepare the data to be inserted as a comma-separated string of values</span>
        <span class="n">data_to_insert</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">max_id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunk</span><span class="p">)])</span>

        <span class="c1"># Execute the INSERT statement to insert the data chunk into the table</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INSERT INTO my_table (id, value) VALUES </span><span class="si">{</span><span class="n">data_to_insert</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Update the maximum ID</span>
        <span class="n">max_id</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

    <span class="c1"># Commit the changes to the database</span>
    <span class="n">cnx</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

    <span class="c1"># Close the cursor and connection</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">cnx</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>



<div class="viewcode-block" id="load_object">
<a class="viewcode-back" href="../mysql_save_load.html#mysql_save_load.load_object">[docs]</a>
<span class="k">def</span> <span class="nf">load_object</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">database</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load numerical data from a MySQL database and return as a NumPy array.</span>
<span class="sd">    </span>
<span class="sd">    This function retrieves all numerical data previously stored using the save_object</span>
<span class="sd">    function from the MySQL database. The data is returned as a flattened NumPy array</span>
<span class="sd">    maintaining the original insertion order based on the sequential ID field.</span>
<span class="sd">    </span>
<span class="sd">    The function connects to the specified MySQL database, executes a SELECT query</span>
<span class="sd">    to retrieve all values from the &#39;my_table&#39; table, and processes the results</span>
<span class="sd">    into a convenient NumPy array format for further analysis or computation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        host (str): MySQL server hostname or IP address (e.g., &#39;localhost&#39;, &#39;192.168.1.100&#39;).</span>
<span class="sd">                   Must be the same server where data was previously saved.</span>
<span class="sd">        user (str): MySQL username with SELECT privileges on the specified database.</span>
<span class="sd">        password (str): Password for the MySQL user account.</span>
<span class="sd">        database (str): Name of the MySQL database containing the stored data.</span>
<span class="sd">                       Must be the same database used in save_object.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A 1D NumPy array containing all numerical values from the database,</span>
<span class="sd">                   ordered by their sequential ID (insertion order). Returns an empty</span>
<span class="sd">                   array if no data exists in the table.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        mysql.connector.Error: If database connection fails, authentication is invalid,</span>
<span class="sd">                              table doesn&#39;t exist, or SQL execution encounters errors.</span>
<span class="sd">        mysql.connector.ProgrammingError: If the &#39;my_table&#39; table doesn&#39;t exist in the database.</span>
<span class="sd">        MemoryError: If the dataset is too large to fit in available memory.</span>
<span class="sd">    </span>
<span class="sd">    Data Format:</span>
<span class="sd">        - Returns data as numpy.float64 array by default</span>
<span class="sd">        - Maintains the original order of data insertion (sorted by ID)</span>
<span class="sd">        - Flattened to 1D array regardless of original data structure</span>
<span class="sd">        - Missing or NULL values are handled according to NumPy&#39;s default behavior</span>
<span class="sd">    </span>
<span class="sd">    Performance Considerations:</span>
<span class="sd">        - Loads entire dataset into memory at once</span>
<span class="sd">        - For very large datasets, consider implementing pagination or streaming</span>
<span class="sd">        - Query performance depends on table size and database indexing</span>
<span class="sd">        - Network transfer time increases with data volume</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Load previously saved data</span>
<span class="sd">        &gt;&gt;&gt; loaded_data = load_object(&#39;localhost&#39;, &#39;myuser&#39;, &#39;mypass&#39;, &#39;mydb&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Loaded {len(loaded_data)} data points&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Data type: {loaded_data.dtype}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Load and analyze data</span>
<span class="sd">        &gt;&gt;&gt; measurements = load_object(&#39;db.example.com&#39;, &#39;analyst&#39;, &#39;secure123&#39;, &#39;experiments&#39;)</span>
<span class="sd">        &gt;&gt;&gt; if len(measurements) &gt; 0:</span>
<span class="sd">        ...     print(f&quot;Mean: {np.mean(measurements):.3f}&quot;)</span>
<span class="sd">        ...     print(f&quot;Std Dev: {np.std(measurements):.3f}&quot;)</span>
<span class="sd">        ...     print(f&quot;Range: [{np.min(measurements):.3f}, {np.max(measurements):.3f}]&quot;)</span>
<span class="sd">        ... else:</span>
<span class="sd">        ...     print(&quot;No data found in database&quot;)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Check for empty table</span>
<span class="sd">        &gt;&gt;&gt; data = load_object(&#39;localhost&#39;, &#39;user&#39;, &#39;pass&#39;, &#39;testdb&#39;)</span>
<span class="sd">        &gt;&gt;&gt; if data.size == 0:</span>
<span class="sd">        ...     print(&quot;Table is empty or doesn&#39;t exist&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Security Notes:</span>
<span class="sd">        - Uses read-only SELECT queries (safe for data integrity)</span>
<span class="sd">        - Credentials are passed directly; consider using environment variables</span>
<span class="sd">        - Ensure proper database user permissions (SELECT on target table)</span>
<span class="sd">        - Connection uses default MySQL encryption settings</span>
<span class="sd">    </span>
<span class="sd">    Database Compatibility:</span>
<span class="sd">        - Expects table structure created by save_object function</span>
<span class="sd">        - Compatible with MySQL 5.7+ and MariaDB 10.2+</span>
<span class="sd">        - Requires &#39;my_table&#39; table with &#39;value&#39; column</span>
<span class="sd">        - ID column is used for ordering but not returned in results</span>
<span class="sd">    </span>
<span class="sd">    Memory Management:</span>
<span class="sd">        - Fetches all data at once using fetchall()</span>
<span class="sd">        - For large datasets, monitor memory usage</span>
<span class="sd">        - Consider using fetchmany() for memory-constrained environments</span>
<span class="sd">        - NumPy array creation may temporarily double memory usage</span>
<span class="sd">    </span>
<span class="sd">    Error Handling:</span>
<span class="sd">        - Connection errors are propagated to caller</span>
<span class="sd">        - Empty tables return empty NumPy array (not None)</span>
<span class="sd">        - Database connection is always properly closed</span>
<span class="sd">        - Cursor cleanup ensures no resource leaks</span>
<span class="sd">    </span>
<span class="sd">    Usage Patterns:</span>
<span class="sd">        &gt;&gt;&gt; # Complete save/load cycle</span>
<span class="sd">        &gt;&gt;&gt; original_data = np.array([1.1, 2.2, 3.3, 4.4, 5.5])</span>
<span class="sd">        &gt;&gt;&gt; save_object(original_data, &#39;localhost&#39;, &#39;user&#39;, &#39;pass&#39;, &#39;mydb&#39;)</span>
<span class="sd">        &gt;&gt;&gt; retrieved_data = load_object(&#39;localhost&#39;, &#39;user&#39;, &#39;pass&#39;, &#39;mydb&#39;)</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(original_data, retrieved_data[-len(original_data):])  # True</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Data validation after loading</span>
<span class="sd">        &gt;&gt;&gt; data = load_object(&#39;localhost&#39;, &#39;user&#39;, &#39;pass&#39;, &#39;mydb&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert data.ndim == 1, &quot;Data should be 1-dimensional&quot;</span>
<span class="sd">        &gt;&gt;&gt; assert data.dtype == np.float64, &quot;Data should be float64&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Connect to the MySQL server</span>
    <span class="n">cnx</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">connector</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">password</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="n">database</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">cnx</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="c1"># Execute the SELECT statement to retrieve the values from the table</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT value FROM my_table&quot;</span><span class="p">)</span>

    <span class="c1"># Fetch all the rows returned by the SELECT statement</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>

    <span class="c1"># Close the cursor and connection</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">cnx</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Flatten the fetched data and return it as a NumPy array</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Saumik Dana.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>