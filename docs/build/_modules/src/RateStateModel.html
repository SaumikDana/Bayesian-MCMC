

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.RateStateModel &mdash; Bayesian MCMC Framework 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Bayesian MCMC Framework
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Python API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Bayesian-Markov-chain-Monte-Carlo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Bayesian MCMC Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">src.RateStateModel</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.RateStateModel</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">setup_path</span>
<span class="kn">from</span> <span class="nn">src.imports</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c1"># Constants</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">0.011</span>
<span class="n">B</span> <span class="o">=</span> <span class="mf">0.014</span>
<span class="n">MU_REF</span> <span class="o">=</span> <span class="mf">0.6</span>
<span class="n">V_REF</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">K1</span> <span class="o">=</span> <span class="mf">1.E-7</span>
<span class="n">START_TIME</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">END_TIME</span> <span class="o">=</span> <span class="mf">50.0</span>

<span class="n">RateStateModel_base</span> <span class="o">=</span> <span class="nb">object</span>  <span class="c1"># Fallback to a base object</span>

<div class="viewcode-block" id="RateStateModel">
<a class="viewcode-back" href="../../src.html#src.RateStateModel.RateStateModel">[docs]</a>
<span class="k">class</span> <span class="nc">RateStateModel</span><span class="p">(</span><span class="n">RateStateModel_base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rate and State Friction Model for earthquake fault mechanics simulation.</span>
<span class="sd">    </span>
<span class="sd">    This class implements the rate and state friction law, a widely used constitutive</span>
<span class="sd">    model in earthquake mechanics that describes the evolution of friction on fault</span>
<span class="sd">    surfaces. The model captures the velocity dependence of friction and the time-</span>
<span class="sd">    dependent healing of fault surfaces through a state variable.</span>
<span class="sd">    </span>
<span class="sd">    The rate and state friction law is governed by:</span>
<span class="sd">    μ = μ₀ + a*ln(V/V_ref) + b*ln(V_ref*θ/Dc)</span>
<span class="sd">    dθ/dt = 1 - V*θ/Dc</span>
<span class="sd">    </span>
<span class="sd">    Where:</span>
<span class="sd">    - μ is the friction coefficient</span>
<span class="sd">    - V is the sliding velocity</span>
<span class="sd">    - θ is the state variable (characteristic healing time)</span>
<span class="sd">    - a, b are material parameters</span>
<span class="sd">    - Dc is the characteristic slip distance</span>
<span class="sd">    - μ₀ is the reference friction coefficient</span>
<span class="sd">    </span>
<span class="sd">    The model includes:</span>
<span class="sd">    - Dynamic loading with time-varying velocity</span>
<span class="sd">    - Spring-block system dynamics with effective stiffness</span>
<span class="sd">    - Optional radiation damping for realistic energy dissipation</span>
<span class="sd">    - Numerical integration using adaptive ODE solvers</span>
<span class="sd">    - Synthetic noise addition to simulate experimental conditions</span>
<span class="sd">    </span>
<span class="sd">    Physical Interpretation:</span>
<span class="sd">    - a &gt; 0: velocity strengthening (direct effect)</span>
<span class="sd">    - b &gt; 0: velocity weakening when combined with state evolution</span>
<span class="sd">    - a-b &lt; 0: potentially unstable sliding (stick-slip behavior)</span>
<span class="sd">    - a-b &gt; 0: stable sliding</span>
<span class="sd">    - Dc controls the distance scale over which state evolves</span>
<span class="sd">    </span>
<span class="sd">    Applications:</span>
<span class="sd">    - Earthquake fault mechanics modeling</span>
<span class="sd">    - Laboratory friction experiments simulation</span>
<span class="sd">    - Seismic cycle studies</span>
<span class="sd">    - Fault stability analysis</span>
<span class="sd">    - Parameter estimation from experimental data</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        a (float): Direct effect parameter (velocity dependence)</span>
<span class="sd">        b (float): Evolution effect parameter (state dependence)</span>
<span class="sd">        mu_ref (float): Reference friction coefficient</span>
<span class="sd">        V_ref (float): Reference sliding velocity</span>
<span class="sd">        k1 (float): Radiation damping coefficient</span>
<span class="sd">        t_start (float): Simulation start time</span>
<span class="sd">        t_final (float): Simulation end time</span>
<span class="sd">        num_tsteps (int): Number of time steps for integration</span>
<span class="sd">        delta_t (float): Time step size</span>
<span class="sd">        mu_t_zero (float): Initial friction coefficient</span>
<span class="sd">        RadiationDamping (bool): Whether to include radiation damping</span>
<span class="sd">        Dc (float): Characteristic slip distance (must be set before evaluation)</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Basic usage</span>
<span class="sd">        &gt;&gt;&gt; model = RateStateModel(number_time_steps=1000, end_time=100.0)</span>
<span class="sd">        &gt;&gt;&gt; model.Dc = 0.02  # Set characteristic distance</span>
<span class="sd">        &gt;&gt;&gt; t, acc, acc_noise = model.evaluate()</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Custom parameters</span>
<span class="sd">        &gt;&gt;&gt; model = RateStateModel()</span>
<span class="sd">        &gt;&gt;&gt; model.a = 0.015  # Modify direct effect</span>
<span class="sd">        &gt;&gt;&gt; model.b = 0.020  # Modify evolution effect</span>
<span class="sd">        &gt;&gt;&gt; model.Dc = 0.01</span>
<span class="sd">        &gt;&gt;&gt; model.RadiationDamping = False  # Disable damping</span>
<span class="sd">        &gt;&gt;&gt; results = model.evaluate()</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Analysis of results</span>
<span class="sd">        &gt;&gt;&gt; t, acceleration, noisy_acceleration = model.evaluate()</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; plt.figure(figsize=(12, 4))</span>
<span class="sd">        &gt;&gt;&gt; plt.subplot(1, 2, 1)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(t, acceleration, label=&#39;Clean signal&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(t, noisy_acceleration, label=&#39;With noise&#39;, alpha=0.7)</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;Time&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;Acceleration&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        - Dieterich, J. H. (1979). Modeling of rock friction</span>
<span class="sd">        - Ruina, A. (1983). Slip instability and state variable friction laws</span>
<span class="sd">        - Marone, C. (1998). Laboratory-derived friction laws and their application</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        - Dc parameter must be set before calling evaluate()</span>
<span class="sd">        - The model uses adaptive ODE integration for numerical stability</span>
<span class="sd">        - Radiation damping is enabled by default for physical realism</span>
<span class="sd">        - Time units are arbitrary but should be consistent throughout</span>
<span class="sd">        - Acceleration output includes synthetic noise for realism</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">number_time_steps</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> 
        <span class="n">start_time</span><span class="o">=</span><span class="n">START_TIME</span><span class="p">,</span> 
        <span class="n">end_time</span><span class="o">=</span><span class="n">END_TIME</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Rate and State friction model with simulation parameters.</span>
<span class="sd">        </span>
<span class="sd">        Sets up the model with default physical parameters based on typical laboratory</span>
<span class="sd">        values for rock friction experiments. The temporal discretization is defined</span>
<span class="sd">        by the number of time steps and the start/end times.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            number_time_steps (int, optional): Number of discrete time steps for numerical</span>
<span class="sd">                                             integration. Higher values improve accuracy but</span>
<span class="sd">                                             increase computation time. Defaults to 500.</span>
<span class="sd">            start_time (float, optional): Simulation start time in arbitrary time units.</span>
<span class="sd">                                        Defaults to START_TIME (0.0).</span>
<span class="sd">            end_time (float, optional): Simulation end time in same units as start_time.</span>
<span class="sd">                                      Must be greater than start_time. Defaults to END_TIME (50.0).</span>
<span class="sd">        </span>
<span class="sd">        Initializes:</span>
<span class="sd">            Physical parameters (from literature values):</span>
<span class="sd">            - a = 0.011: Direct effect parameter (dimensionless)</span>
<span class="sd">            - b = 0.014: Evolution effect parameter (dimensionless)</span>
<span class="sd">            - mu_ref = 0.6: Reference friction coefficient (dimensionless)</span>
<span class="sd">            - V_ref = 1.0: Reference velocity (length/time)</span>
<span class="sd">            - k1 = 1e-7: Radiation damping coefficient</span>
<span class="sd">            </span>
<span class="sd">            Temporal parameters:</span>
<span class="sd">            - Time range and discretization</span>
<span class="sd">            - Time step size (computed from range and number of steps)</span>
<span class="sd">            </span>
<span class="sd">            Initial conditions:</span>
<span class="sd">            - Initial friction coefficient set to reference value</span>
<span class="sd">            </span>
<span class="sd">            Model options:</span>
<span class="sd">            - Radiation damping enabled by default</span>
<span class="sd">            - Dc parameter initialized to None (must be set before evaluation)</span>
<span class="sd">        </span>
<span class="sd">        Note:</span>
<span class="sd">            - The time step is automatically computed as (end_time - start_time) / number_time_steps</span>
<span class="sd">            - Physical parameters use typical values from rock friction literature</span>
<span class="sd">            - All parameters can be modified after initialization</span>
<span class="sd">            - The model assumes consistent units throughout (user responsibility)</span>
<span class="sd">        </span>
<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Default simulation (50 time units, 500 steps)</span>
<span class="sd">            &gt;&gt;&gt; model = RateStateModel()</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # High-resolution, long-duration simulation</span>
<span class="sd">            &gt;&gt;&gt; model = RateStateModel(number_time_steps=2000, end_time=200.0)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Short-duration, coarse simulation</span>
<span class="sd">            &gt;&gt;&gt; model = RateStateModel(number_time_steps=100, end_time=10.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define model constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_ref</span> <span class="o">=</span> <span class="n">MU_REF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_ref</span> <span class="o">=</span> <span class="n">V_REF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">=</span> <span class="n">K1</span>

        <span class="c1"># Define time range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span> <span class="o">=</span> <span class="n">start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_final</span> <span class="o">=</span> <span class="n">end_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_tsteps</span> <span class="o">=</span> <span class="n">number_time_steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">number_time_steps</span>

        <span class="c1"># Define initial conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_t_zero</span> <span class="o">=</span> <span class="n">MU_REF</span>

        <span class="c1"># Add additional model constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RadiationDamping</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span>
        
<div class="viewcode-block" id="RateStateModel.evaluate">
<a class="viewcode-back" href="../../src.html#src.RateStateModel.RateStateModel.evaluate">[docs]</a>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the rate and state friction model using numerical integration.</span>
<span class="sd">        </span>
<span class="sd">        This method performs the complete simulation of the rate and state friction</span>
<span class="sd">        system by solving the coupled differential equations numerically. The system</span>
<span class="sd">        includes the friction evolution, state variable evolution, and dynamic loading</span>
<span class="sd">        with optional radiation damping.</span>
<span class="sd">        </span>
<span class="sd">        The method solves the system:</span>
<span class="sd">        dμ/dt = k&#39;*(V_l - V) - k1*dV/dt  (with radiation damping)</span>
<span class="sd">        dθ/dt = 1 - V*θ/Dc</span>
<span class="sd">        dV/dt = (V/a)*(dμ/dt - b/θ*dθ/dt)</span>
<span class="sd">        </span>
<span class="sd">        Where:</span>
<span class="sd">        - V is computed from the rate and state law: V = V_ref * exp((μ-μ₀-b*ln(V_ref*θ/Dc))/a)</span>
<span class="sd">        - V_l is the loading velocity: V_ref * (1 + exp(-t/a1) * sin(a2*t))</span>
<span class="sd">        - k&#39; is the effective stiffness: 1e-2 * 10 / Dc</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: A 3-element tuple containing:</span>
<span class="sd">                - t (np.ndarray): Time array with shape (num_steps,). Time values</span>
<span class="sd">                                from t_start to t_final with delta_t spacing.</span>
<span class="sd">                - acc (np.ndarray): Clean acceleration array with shape (num_steps,).</span>
<span class="sd">                                  Computed as numerical derivative of velocity.</span>
<span class="sd">                - acc_noise (np.ndarray): Noisy acceleration array with shape (num_steps,).</span>
<span class="sd">                                        Clean acceleration plus 100% relative Gaussian noise.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If Dc is None (characteristic distance must be set before evaluation)</span>
<span class="sd">            RuntimeError: If ODE integration fails or becomes unstable</span>
<span class="sd">            FloatingPointError: If numerical overflow/underflow occurs during integration</span>
<span class="sd">        </span>
<span class="sd">        Algorithm Details:</span>
<span class="sd">            1. Sets up the differential equation system with nested friction function</span>
<span class="sd">            2. Initializes arrays for state variables (μ, θ, V) and outputs</span>
<span class="sd">            3. Uses Dormand-Prince 8(5,3) ODE solver with adaptive step size</span>
<span class="sd">            4. Integrates over the specified time range with fixed output intervals</span>
<span class="sd">            5. Computes acceleration via finite differences</span>
<span class="sd">            6. Adds synthetic noise to acceleration for realism</span>
<span class="sd">        </span>
<span class="sd">        Physical Interpretation:</span>
<span class="sd">            - Loading function creates time-varying driving velocity</span>
<span class="sd">            - Effective stiffness couples system dynamics to Dc parameter</span>
<span class="sd">            - Radiation damping models energy dissipation during rapid sliding</span>
<span class="sd">            - State variable evolution controls friction memory effects</span>
<span class="sd">            - Acceleration output represents measurable seismic signal</span>
<span class="sd">        </span>
<span class="sd">        Numerical Considerations:</span>
<span class="sd">            - Uses high-precision ODE solver (rtol=1e-6, atol=1e-10)</span>
<span class="sd">            - Adaptive time stepping for numerical stability</span>
<span class="sd">            - Handles stiff systems through implicit methods</span>
<span class="sd">            - Acceleration computed via backward differences for stability</span>
<span class="sd">        </span>
<span class="sd">        Noise Model:</span>
<span class="sd">            - Multiplicative Gaussian noise: acc_noise = acc + 1.0 * |acc| * N(0,1)</span>
<span class="sd">            - 100% relative noise level (signal-dependent)</span>
<span class="sd">            - Models experimental measurement uncertainty</span>
<span class="sd">            - Preserves sign of acceleration signal</span>
<span class="sd">        </span>
<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; model = RateStateModel(number_time_steps=1000)</span>
<span class="sd">            &gt;&gt;&gt; model.Dc = 0.02  # Required: set characteristic distance</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Run simulation</span>
<span class="sd">            &gt;&gt;&gt; time, clean_acc, noisy_acc = model.evaluate()</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Analyze results</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Simulation duration: {time[-1] - time[0]:.2f}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Max acceleration: {np.max(np.abs(clean_acc)):.4f}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;RMS noise level: {np.std(noisy_acc - clean_acc):.4f}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Check for stick-slip behavior</span>
<span class="sd">            &gt;&gt;&gt; velocity_proxy = np.gradient(clean_acc)  # Rough velocity estimate</span>
<span class="sd">            &gt;&gt;&gt; if np.std(velocity_proxy) &gt; np.mean(np.abs(velocity_proxy)):</span>
<span class="sd">            ...     print(&quot;Stick-slip behavior detected&quot;)</span>
<span class="sd">        </span>
<span class="sd">        Performance Notes:</span>
<span class="sd">            - Computation time scales linearly with number_time_steps</span>
<span class="sd">            - Memory usage is O(number_time_steps) for storing trajectories</span>
<span class="sd">            - ODE solver may slow down for stiff systems (small Dc, large a-b)</span>
<span class="sd">            - Consider reducing tolerance for faster computation if high precision not needed</span>
<span class="sd">        </span>
<span class="sd">        Validation:</span>
<span class="sd">            - Check energy conservation (if radiation damping disabled)</span>
<span class="sd">            - Verify friction bounds: μ should remain physically reasonable</span>
<span class="sd">            - Monitor state variable: θ &gt; 0 always (physical constraint)</span>
<span class="sd">            - Compare with analytical solutions for simple loading cases</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">friction</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Define the rate and state friction differential equation system.</span>
<span class="sd">            </span>
<span class="sd">            This nested function computes the time derivatives of the state variables</span>
<span class="sd">            (friction coefficient, state variable, and velocity) according to the</span>
<span class="sd">            rate and state friction law with dynamic loading and optional radiation damping.</span>
<span class="sd">            </span>
<span class="sd">            The function implements the coupled system:</span>
<span class="sd">            1. Rate and state friction law (algebraic constraint)</span>
<span class="sd">            2. State variable evolution (Dieterich law)</span>
<span class="sd">            3. Dynamic equilibrium with loading and damping</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                t (float): Current time value during integration</span>
<span class="sd">                y (np.ndarray): State vector [μ, θ, V] where:</span>
<span class="sd">                              y[0] = μ (friction coefficient)</span>
<span class="sd">                              y[1] = θ (state variable, healing time)</span>
<span class="sd">                              y[2] = V (sliding velocity)</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.ndarray: Time derivatives [dμ/dt, dθ/dt, dV/dt] as column vector</span>
<span class="sd">                           with shape (3, 1)</span>
<span class="sd">            </span>
<span class="sd">            Physical Model:</span>
<span class="sd">                - Loading velocity: V_l = V_ref * (1 + exp(-t/20) * sin(10*t))</span>
<span class="sd">                - Effective stiffness: k&#39; = 0.1 / Dc</span>
<span class="sd">                - Friction law: V = V_ref * exp((μ-μ₀-b*ln(V_ref*θ/Dc))/a)</span>
<span class="sd">                - State evolution: dθ/dt = 1 - V*θ/Dc</span>
<span class="sd">                - Force balance: dμ/dt = k&#39;*(V_l - V) - k1*dV/dt (with damping)</span>
<span class="sd">            </span>
<span class="sd">            Note:</span>
<span class="sd">                - Uses current model parameters (a, b, Dc, etc.)</span>
<span class="sd">                - Handles radiation damping through velocity coupling</span>
<span class="sd">                - Maintains physical constraints implicitly</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Just to help readability</span>
            <span class="c1"># y[0] is mu (friction)</span>
            <span class="c1"># y[1] is theta</span>
            <span class="c1"># y[2] is velocity</span>
            
            <span class="n">V_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_ref</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dc</span>

            <span class="c1"># effective spring stiffness</span>
            <span class="n">kprime</span> <span class="o">=</span> <span class="mf">1e-2</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">dc</span>

            <span class="c1"># loading</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">V_l</span> <span class="o">=</span> <span class="n">V_ref</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">a1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">a2</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

            <span class="c1"># initialize the array of derivatives</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">dydt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># compute v</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_ref</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">V_ref</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dc</span><span class="p">))</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">V_ref</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

            <span class="c1"># time derivative of theta</span>
            <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">v</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dc</span>

            <span class="c1"># time derivative of mu</span>
            <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kprime</span> <span class="o">*</span> <span class="n">V_l</span> <span class="o">-</span> <span class="n">kprime</span> <span class="o">*</span> <span class="n">v</span>

            <span class="c1"># time derivative of velocity</span>
            <span class="n">dydt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span> <span class="o">/</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># add radiation damping term if specified</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RadiationDamping</span><span class="p">:</span>
                <span class="c1"># time derivative of mu with radiation damping</span>
                <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">*</span> <span class="n">dydt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># time derivative of velocity with radiation damping</span>
                <span class="n">dydt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span> <span class="o">/</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">dydt</span>
        
        <span class="c1"># Calculate the number of steps to take</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">t_final</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span><span class="p">))</span>

        <span class="c1"># Create arrays to store trajectory</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">acc</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">),</span>\
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">),</span>\
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">),</span>\
                        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">),</span>\
                            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
        <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span>
        <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_ref</span>
        <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dc</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_ref</span>
        <span class="n">velocity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_ref</span>
        <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Set up the ODE solver</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">ode</span><span class="p">(</span><span class="n">friction</span><span class="p">)</span><span class="o">.</span><span class="n">set_integrator</span><span class="p">(</span><span class="s1">&#39;dop853&#39;</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span>

        <span class="c1"># Set the initial conditions for the ODE solver</span>
        <span class="n">r</span><span class="o">.</span><span class="n">set_initial_value</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_t_zero</span><span class="p">,</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">velocity</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Integrate the ODE(s) across each delta_t timestep</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">r</span><span class="o">.</span><span class="n">successful</span><span class="p">()</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">num_steps</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span><span class="p">)</span>
            <span class="c1"># Store the results to plot later</span>
            <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">t</span>
            <span class="n">mu</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">velocity</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">acc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">velocity</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">velocity</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_t</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Add some noise to the acceleration data to simulate real-world noise</span>
        <span class="n">acc_noise</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">acc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Return the data for plotting and analysis</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">acc_noise</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Saumik Dana.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>